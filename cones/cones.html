<!doctype html>
<html>
<head>
  <meta charset="utf-8"></meta>

  <script src="vue.js"></script>
  <!--script src="vue-color.min.js"></script-->

  <style>
  .withaxes {
    border: 2px solid black;
    border-width: 0 0 2px 2px;
  }
  .withaxes {
    width: 400px;
    height: 400px;
  }
  .point {
    fill: none;
    stroke: black;
    stroke-width: 1;
  }
  .shade {
    fill: #0000007F;
  }
  .lowershade {
    fill: #0000002F;
  }
  </style>

</head>
<body>


  <script type="text/x-template" id="tpl-thesvg">
  </script>

  <div id="app">
    <div class="all">
      <svg class="withaxes">
        <g v-for="o in fullPoints" :transform="'translate('+o.t*200+', '+(400-400*o.f)+')'">
          <rect class="point" x="-2" y="-2" width="4" height="4"/>
          <path class="shade" :d="'M 0 0 L '+(-400/o.slope)+' -400 l '+(2*400/o.slope)+' 0 Z'"/>
        </g>
        <path class="lowershade" :d="'M 0 400 l 0 '+(-400*bestF)+' l 400 0 L 400 400 Z'"/>
      </svg>
      <br/> P = <input type="number" v-model="P"/>
      <br/> N = <input type="number" v-model="N"/>
      <br/> Î² = <input type="range" min="0.01" max="5" step="0.01" v-model="beta"/> ({{beta}})
      <br/> <label><input id="focus" type="checkbox" v-model="enhance"/> enhanced</label>
    </div>
  </div>

<!-- pointer-events none on the png image -->


  <script>
  var myeach = function(coll, cb) {
    [].forEach.call(coll, cb);
  };

function l2norm(x, y) {
  return Math.sqrt(x*x + y*y);
}
function startApp() {

  Vue.component('cone', {
    template: '#tpl-thesvg',
    compiled: function() {
      alert("comp")
      console.log("COMPILED", (this.$el))
    },
    methods: {
    }
  });

  window.app = new Vue({
    el: '#app',
    data: {
      enhance: false,
      P: 100,
      N: 1000,
      beta: 1,
      points: [
        {t: .2, fp: 30, fn: 20},
        {t: .6, fp: 20, fn: 20},
        {t: 1, fp: 100, fn: 50},
        {t: 1.3, fp: 50, fn: 80},
        {t: 1.35, fp: 500, fn: 30},
      ],
    },
    methods: {
      toggleEnhance() { this.enhance = !this.enhance; }
    },
    computed: {
      theirs: function() { return !this.enhance; },
      M: function() {
        return l2norm(this.P, this.N);
      },
      phi: function() {
        return 1/(this.beta*this.beta*this.P);
      },
      fullPoints: function() {
        return this.points.map( o=> {
          var normE = l2norm(o.fp, o.fn);
          var tp = this.P - o.fn;
          var tn = this.N - o.fp;
          var f = (1+this.beta)*tp / ((1+this.beta)*tp + this.beta*o.fn + o.fp);
          {
            let e1 = o.fn;
            let e2 = o.fp;

            let N1a2 = -e2;
            let N1a1 = N1a2*(this.P - e1) / (this.P + e2);
            let N1n = l2norm(e1 + N1a1, e2 + N1a2);

            let N2a2 = Math.min(this.N - e2, e1*(this.P + e2) / (this.P - e1));
            let N2a1 = N1a2*(this.P - e1) / (this.P + e2);
            let N2n = l2norm(e1 + N2a1, e2 + N2a2);

            var normErestricted = Math.max(N1n, N2n);
          }
          var slope;
          if (this.theirs) {
            slope = 2 * 2 * this.M * this.phi;
          } else {
            slope = Math.sqrt(2) * (normE+normErestricted) * this.phi;
          }
          var res = {...o, tp, tn, f, slope};
          console.log(res);
          return res;
        });
      },
      bestF: function() {
        return Math.max.apply(Math, this.fullPoints.map(o=>o.f));
      },
    },
  });
  document.getElementById('focus').focus();
}
startApp();
  </script>

</body>
</html>
